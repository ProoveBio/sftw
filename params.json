{"google":"","body":"South For the Winter (sftw)\r\n===========================\r\n\r\n*South for the Winter* (`sftw`) is a db migration tool, a port of the\r\n[Akrabat](https://github.com/akrabat/Akrabat) db migration tool. In fact, it's as close\r\nto a straight rip-off as can be with one primary difference: `Akrabat` uses a \r\n`Zend\\Db` database adapter and is largely targeted towards \r\n[Zend Framework](http://framework.zend.com/) apps, while `sftw` uses a vanilla \r\n[PDO](http://www.php.net/manual/en/book.pdo.php) adapter. Because of this, `sftw` \r\nshould be usable in circumstances where the ZF components are unavailable or \r\nmerely considered too heavywight.\r\n\r\nInstall\r\n=======\r\n\r\nAs a standalone component\r\n-------------------------\r\n\r\n```\r\n$ git clone git@github.com:startupdevs/sftw.git\r\n```\r\n\r\nIn another project via Composer\r\n-------------------------------\r\n\r\nAdd to your project's `composer.json` as follows:\r\n```\r\n{\r\n\t\"repositories\" : [\r\n\t\t{\r\n\t\t\t\"type\" : \"vcs\",\r\n\t\t\t\"url\" : \"https://github.com/startupdevs/sftw.git\"\r\n\t\t}\r\n\t]\r\n\t\"require\": {\r\n\t\t\"startupdevs/sftw\" : \"dev-master\"\r\n\t}\r\n}\r\n```\r\n\r\nOptionally, you can add a `bin-dir` entry into the `config` section of your \r\nproject's `composer.json` to specify where the `sftw` CLI scripts are symlinked.\r\n\r\n```\r\n{\r\n    \"config\": {\r\n        \"bin-dir\": \"scripts\"\r\n    }\t\r\n}\r\n```\r\n\r\nThen in your project root (assuming you used the `bin-dir` setting above):\r\n\r\n\t$ php composer.phar update\r\n\t$ chmod +x ./scripts/sftw.php\r\n\t$ ln -s ./scripts/sftw.php ./scripts/sftw\r\n\r\nUsage\r\n=====\r\n\r\nAssumes you have installed SFTW via Composer in your project `myproject` with a `bin-dir`\r\nvalue of `scripts`.\r\n\r\nDefine one migration class - extending `Dws\\Db\\Schema\\AbstractChange` for each schema \r\nchange you wish to implement. For example:\r\n\r\n```\r\n/*\r\n* Adding your own namespace to the migration classes is optional. If you do,\r\n* then you will be required to specify it during the invocation of the migration\r\n* script.\r\n*/\r\nnamespace Ooga\\Db\\Migration;\r\n\r\nuse Dws\\Db\\Schema\\AbstractChange as SchemaChange;\r\n\r\nclass AddUserTable extends SchemaChange\r\n{\r\n\tpublic function up()\r\n\t{\r\n\t\t$sql = '\r\n\t\t\tCREATE TABLE `user` (\r\n\t\t\t\t`id` INT(11) UNSIGNED NOT NULL,\r\n\t\t\t\t`name` VARCHAR(255)\r\n\t\t\t)\r\n\t\t';\r\n\t\t$this->pdo->exec($sql);\t\r\n\t}\r\n\r\n\tpublic function down()\r\n\t{\r\n\t\t$sql = 'DROP TABLE `user`';\r\n\t\t$this->pdo->exec($sql);\r\n\t}\r\n\r\n}\r\n```\r\n\r\nSave this file as:\r\n\r\n\t/path/to/myproject/scripts/migrations/001-AddUserTable.php\r\n\r\nInvocation, starting in the project root, is as follows:\r\n\r\nTo display the current schema version:\r\n\r\n    $ ./scripts/sftw current --host myhost --user myuser --pass mypass --db mydb\r\n\r\nTo upgrade to latest schema version:\r\n\r\n    $ ./scripts/sftw latest --host myhost --user myuser --pass mypass --db mydb --path ./scripts/migrations --namespace Ooga/Db/Migrations\r\n\r\nNote that for convenience, you can use forward slashes (/) in the namespace. They will be reversed before use.\r\n\r\nTo migrate to a specific schema version (in this case 1):\r\n\r\n    $ ./scripts/sftw migrate 1 --host myhost --user myuser --pass mypass --db mydb --path ./scripts/migrations --namespace Ooga/Db/Migrations\r\n\r\nTo roll all the way back to the state before the first migration file:\r\n\r\n    $ ./scripts/sftw migrate 0 --host myhost --user myuser --pass mypass --db mydb --path ./scripts/migrations --namespace Ooga/Db/Migrations\r\n\r\nTo set the schema pointer to a particular version (when you have some migrations already \"basked-in\" to the deployed db, for example):\r\n\r\n    $ ./scripts/sftw point-to 5 --host myhost --user myuser --pass mypass --db mydb --path ./scripts/migrations --namespace Ooga/Db/Migrations\r\n\r\nNote: Depending upon how you write your migrations, schema upgrades and rollbacks can be \r\n\"data destructive\". This is especially true of ADD/DROP TABLE and ALTER TABLE ADD/DROP COLUMN calls, \r\nbut is even true when merely changing the format of a column. \r\n\r\nFor example, consider altering a datetime field into a integer Unix timestamp. \r\nA straight cast of a datetime value into an integer will result in a 0 value. \r\nA return to datetime will result in a 1970 date. To avoid this, your migration\r\nmethods can perform the conversion as follows:\r\n\r\n1. create a temp column of the desired type to store the converted data\r\n2. drop the targeted column\r\n3. add converted data into the temp column\r\n4. drop the temp column \r\n\r\nRollbacks would obviously need to work in reverse.\r\n\r\nGenerally speaking, an upgrade/rollback sequence will restore the **schema** as \r\nexpected, but unless special steps - as above - are taken to save/protect the \r\naffected **data**, it will likely be lost.\r\n\r\nNext Steps\r\n==========\r\n\r\n1. Allow a local config file (with some default name like `sftw.ini`) to contain \r\nconnection/namespace/path params, similar to how `phpunit` employs `phpunit.xml` \r\nby default.\r\n\r\n2. Support multiple environments, allowing you to define connection/namespace/path \r\nsettings based upon environment (development, staging, production, etc).\r\n\r\nFinally\r\n==========\r\n\r\nEnjoy the warm weather.\r\n","tagline":"South For the Winter","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"SFTW"}